<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Nick&#39;s Blog</title>
  <subtitle>出发之前永远是梦想 上路之后永远是挑战</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://nickgo.com/"/>
  <updated>2016-07-08T14:53:38.000Z</updated>
  <id>http://nickgo.com/</id>
  
  <author>
    <name>Nick Chang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World - new</title>
    <link href="http://nickgo.com/2016/07/08/hello-world/"/>
    <id>http://nickgo.com/2016/07/08/hello-world/</id>
    <published>2016-07-08T11:20:28.000Z</published>
    <updated>2016-07-08T14:53:38.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/0060lm7Tgw1f2jo610sk3j31hb0u0qkh.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;Welcome to &lt;a href=&quot;http://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;http://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;http://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub&lt;/a&gt;.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;http://hexo.io/docs/writing.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Writing&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Run-server&quot;&gt;&lt;a href=&quot;#Run-server&quot; class=&quot;headerlink&quot; title=&quot;Run server&quot;&gt;&lt;/a&gt;Run server&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ hexo server&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;http://hexo.io/docs/server.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Server&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Generate-static-files&quot;&gt;&lt;a href=&quot;#Generate-static-files&quot; class=&quot;headerlink&quot; title=&quot;Generate static files&quot;&gt;&lt;/a&gt;Generate static files&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ hexo generate&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;http://hexo.io/docs/generating.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Generating&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Deploy-to-remote-sites&quot;&gt;&lt;a href=&quot;#Deploy-to-remote-sites&quot; class=&quot;headerlink&quot; title=&quot;Deploy to remote sites&quot;&gt;&lt;/a&gt;Deploy to remote sites&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ hexo deploy&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;http://hexo.io/docs/deployment.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Deployment&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/0060lm7Tgw1f2jo610sk3j31hb0u0qkh.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;Welcome to &lt;a href=&quot;http://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;http://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;http://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Javascript高级特性之call和apply</title>
    <link href="http://nickgo.com/2016/05/18/Javascript%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B9%8Bcall%E5%92%8Capply/"/>
    <id>http://nickgo.com/2016/05/18/Javascript高级特性之call和apply/</id>
    <published>2016-05-18T11:57:08.000Z</published>
    <updated>2016-05-18T13:15:24.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/0060lm7Tgw1f3zt6vfykkj308y04cglr.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在Javascript中，call和apply是两个神奇的方法，但同时也是容易令人迷惑的两个方法，乃至许多对Javascript有经验的人也不太清楚他们的用法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;Javascript高级特性之call和apply&quot;&gt;&lt;a href=&quot;#Javascript高级特性之call和apply&quot; class=&quot;headerlink&quot; title=&quot;Javascript高级特性之call和apply&quot;&gt;&lt;/a&gt;Javascript高级特性之call和apply&lt;/h1&gt;&lt;h2 id=&quot;1-call和apply&quot;&gt;&lt;a href=&quot;#1-call和apply&quot; class=&quot;headerlink&quot; title=&quot;1.call和apply&quot;&gt;&lt;/a&gt;1.call和apply&lt;/h2&gt;&lt;p&gt;call和apply的功能是以不同的对象作为上下文来调用某个函数。简而言之，就是允许一个对象区调用另一个对象的成员函数。乍一看似乎很不可思议，而且容易引起混乱，但其实Javascript并没有严格的所谓”成员函数”的概念，函数与对象的所属关系在调用时才展现出来。灵活使用call和apply可以节省不少的时间，在后面我们可以看到，call可以用于实现对象的继承。&lt;/p&gt;
&lt;p&gt;call和apply的功能是一致的，两者细微的差别在于call以参数表来接受被调用函数的参数，而apply以数组来接受被调用函数的参数。call和apply的语法分别是：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;func.call(thisArg[,arg1[,arg2[, ...]]]);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;func.apply(thisArg[,argsArray]);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中，func是函数的引用，thisArg是func被调用时的上下文对象，arg1、arg2或argsArray是传入func的参数。我们以下面一段代码为例介绍call的工作机制：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; someuser = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    name: &lt;span class=&quot;string&quot;&gt;&#39;nick&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    display: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;words&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name + &lt;span class=&quot;string&quot;&gt;&#39; says &#39;&lt;/span&gt; + words);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; foo = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    name: &lt;span class=&quot;string&quot;&gt;&#39;foobar&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;someuser.display.call(foo, &lt;span class=&quot;string&quot;&gt;&#39;hello&#39;&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//输出 foobar says hello&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;用Node.js运行这段代码，我们可以看到控制台输出了foobar。Someuser.display是被调用的函数，它通过call将上下文改变为foo对象，因此在函数体内访问this.name时，实际上访问的是foo.name,因而输出了foobar。&lt;/p&gt;
&lt;h2 id=&quot;2-bind&quot;&gt;&lt;a href=&quot;#2-bind&quot; class=&quot;headerlink&quot; title=&quot;2.bind&quot;&gt;&lt;/a&gt;2.bind&lt;/h2&gt;&lt;p&gt;如何改变被调用函数上下文呢？前面说过，可以用call或apply方法，但是如果重复使用会不方便，因为每次都要把上下文对象作为参数传递，而且还会使代码变得不直观。针对这种情况，我们可以使用bind方法来永久地绑定函数的上下文，使其无论被谁调用，上下文都是固定的。bind语法如下：&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;func.bind(thisArg[, arg1[, arg2[, ...]]])&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其中func是待绑定函数，thisArg是改变的上下文对象，arg1、arg2是绑定的参数表。bind方法返回值是上下文为thisArg的func。通过下面例子可以帮你理解bind的使用方法：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; someuser = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    name: &lt;span class=&quot;string&quot;&gt;&#39;nick&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    func: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; foo = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    name: &lt;span class=&quot;string&quot;&gt;&#39;foobar&#39;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;foo.func = someuser.func;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;foo.func(); &lt;span class=&quot;comment&quot;&gt;//输出 foobar&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;foo.func1 = someuser.func.bind(someuser)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;foo.func1();&lt;span class=&quot;comment&quot;&gt;//输出nick&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;func = someuser.func.bind(foo);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;func();&lt;span class=&quot;comment&quot;&gt;//输出foobar&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;func2 = func;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;func2();&lt;span class=&quot;comment&quot;&gt;//输出foobar&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面代码直接将foo.func赋值为someuser.func，调用foo.func()时，this指针为foo，所以输出结果是foobar。foo.func1使用了bind方法，将someuser作为this指针绑定到someuser.func，调用foo.func1()时，this指针为someuser，所以输出结果是nick。全局函数func同样使用了bind方法，将foo作为this指针绑定到someuser.func，调用func()时，this指针为foo，所以输出结果是foobar。而func2直接绑定过的func赋值过来，与func行为完全相同。&lt;/p&gt;
&lt;h2 id=&quot;3-使用bind绑定参数表&quot;&gt;&lt;a href=&quot;#3-使用bind绑定参数表&quot; class=&quot;headerlink&quot; title=&quot;3.使用bind绑定参数表&quot;&gt;&lt;/a&gt;3.使用bind绑定参数表&lt;/h2&gt;&lt;p&gt;bind 方法还有一个重要的功能：绑定参数表，如下例所示。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    name: &lt;span class=&quot;string&quot;&gt;&#39;nick&#39;&lt;/span&gt;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    says: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;act, obj&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name + &lt;span class=&quot;string&quot;&gt;&#39; &#39;&lt;/span&gt; + act + &lt;span class=&quot;string&quot;&gt;&#39; &#39;&lt;/span&gt; + obj);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;person.says(&lt;span class=&quot;string&quot;&gt;&#39;love&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;sal&#39;&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//nick love sal&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;nickLoves = person.says.bind(person, &lt;span class=&quot;string&quot;&gt;&#39;love&#39;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;nickLoves(&lt;span class=&quot;string&quot;&gt;&#39;you&#39;&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//输出nick love you&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以看到，nickLoves将this指针绑定到了person，并将第一个参数绑定到love,之后再调用nickLoves的时候，只需传入第三个参数。这个特性可以用于创建一个函数的“捷径“，之后我们可以通过这个”捷径“调用，以便在代码多出调用时省略重复输入相同的参数。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/0060lm7Tgw1f3zt6vfykkj308y04cglr.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在Javascript中，call和apply是两个神奇的方法，但同时也是容易令人迷惑的两个方法，乃至许多对Javascript有经验的人也不太清楚他们的用法。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://nickgo.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Javascript" scheme="http://nickgo.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript高级特性之闭包</title>
    <link href="http://nickgo.com/2016/05/18/Javascript%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E4%B9%8B%E9%97%AD%E5%8C%85/"/>
    <id>http://nickgo.com/2016/05/18/Javascript高级特性之闭包/</id>
    <published>2016-05-18T11:56:02.000Z</published>
    <updated>2016-05-18T12:22:44.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/0060lm7Tgw1f3zslcb9f5j309o05d74c.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;闭包（closure）是函数式编程中的概念，出现于20世纪60年代。闭包的严格定义是“由函数（环境）及其封闭式的自由变量组成的集合体。”这个定义对于大家来说有些晦涩难懂，所以让我们先通过例子和不那么严格的解释来说明何为闭包，然后再举例说明一些闭包的经典用途。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;JavaScript高级特性之关于闭包的理解&quot;&gt;&lt;a href=&quot;#JavaScript高级特性之关于闭包的理解&quot; class=&quot;headerlink&quot; title=&quot;JavaScript高级特性之关于闭包的理解&quot;&gt;&lt;/a&gt;JavaScript高级特性之关于闭包的理解&lt;/h1&gt;&lt;h2 id=&quot;1-什么是闭包&quot;&gt;&lt;a href=&quot;#1-什么是闭包&quot; class=&quot;headerlink&quot; title=&quot;1.什么是闭包&quot;&gt;&lt;/a&gt;1.什么是闭包&lt;/h2&gt;&lt;p&gt;通俗地讲，Javascript中每个的函数都是一个闭包，但通常意义上嵌套的函数更能够体现出闭包的特性，看下面的这个例子：&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; generateClosure = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; count = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; get = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        count ++;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; count;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; get;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; counter = generateClosure();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(counter()); &lt;span class=&quot;comment&quot;&gt;//输出1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(counter()); &lt;span class=&quot;comment&quot;&gt;//输出2&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(counter()); &lt;span class=&quot;comment&quot;&gt;//输出3&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这段代码中，generateClosure()函数中有一个局部变量count，初值为0.还有一个叫做get的函数，get将其父作用域，也就是generateClosure()函数中的count变量加1，并返回count的值。generateClosure()的返回值是get函数。在外部我们通过counter变量调用了generateClosure()函数并获取了它的返回值，也就是get函数，接下来反复调用了counter(),我们发现每次返回值都递增了1.&lt;/p&gt;
&lt;p&gt;让我们看看上面的例子有什么特点，按照通常命令式编程思维的理解，count是generateClosure函数内部的变量，它的生命周期就是generateClosure被调用的时期，当generateClosure从调用栈中返回时，count变量申请的空间也就被释放。问题是，在generateClusure()调用结束后，counter()却引用了“已经释放了的”count变量，而且非但没有出错，反而每次调用counter()时还修改并返回了count。这是怎么回事呢？&lt;/p&gt;
&lt;p&gt;这正是所谓的闭包特性。当一个函数返回它内部定义的一个函数时，就产生了一个闭包，闭包不但包括被返回的函数，还包括这个函数的定义环境。上面例子中，当函数generateClosure()的内部函数get被一个外部变量counter引用时，counter和generateClosure()局部变量就是一个闭包。如果还不够清晰，下面这个例子可以帮助你理解：&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; generateClosure = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; count = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; get = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        count++;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; count;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; get;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; counter1 = generateClosure();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; counter2 = generateClosure();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(counter1()); &lt;span class=&quot;comment&quot;&gt;//输出1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(counter2()); &lt;span class=&quot;comment&quot;&gt;//输出1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(counter1()); &lt;span class=&quot;comment&quot;&gt;//输出2&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(counter1()); &lt;span class=&quot;comment&quot;&gt;//输出3&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(counter2()); &lt;span class=&quot;comment&quot;&gt;//输出2&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面这个例子解释了闭包是如何产生的：counter1和counter2分别调用了generateClosure()函数，生成了两个闭包的实例，它们内部引用的count变量分别属于各自的运行环境。我们可以理解为，在generateClosure()返回get函数时，私下将get可能引用到的generateClosure()函数的内部变量(也就是count变量)也返回了，并在内存中生成了一个副本，之后generateClosure()返回的函数的两个实例counter1和counter2就是相互独立的了。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;2-闭包的用途&quot;&gt;&lt;a href=&quot;#2-闭包的用途&quot; class=&quot;headerlink&quot; title=&quot;2.闭包的用途&quot;&gt;&lt;/a&gt;2.闭包的用途&lt;/h2&gt;&lt;h3 id=&quot;1-嵌套的回调函数&quot;&gt;&lt;a href=&quot;#1-嵌套的回调函数&quot; class=&quot;headerlink&quot; title=&quot;1.嵌套的回调函数&quot;&gt;&lt;/a&gt;1.嵌套的回调函数&lt;/h3&gt;&lt;p&gt;闭包有两个主要的用途，一是实现嵌套的函数，二是隐藏对象的细节。让我们先看下面这段代码示例，了解嵌套的回调函数。如下代码是在Node.js中使用MongoDB实现一个简单的增加用户的功能：&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;exports.add_user = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;user_info, callback&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; uid = &lt;span class=&quot;built_in&quot;&gt;parseInt&lt;/span&gt;(user_info[&lt;span class=&quot;string&quot;&gt;&#39;uid&#39;&lt;/span&gt;]);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    mongodb.open(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;err, db&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(err) &amp;#123;callback(err);&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        db.collection(&lt;span class=&quot;string&quot;&gt;&quot;users&quot;&lt;/span&gt;,&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;err,collection&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(err) &amp;#123;callback(err);&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            collection.ensureIndex(&lt;span class=&quot;string&quot;&gt;&quot;uid&quot;&lt;/span&gt;,&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;err&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(err) &amp;#123;callback(err);&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                collection.ensureIndex(&lt;span class=&quot;string&quot;&gt;&quot;username&quot;&lt;/span&gt;,&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;err&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(err) &amp;#123;callback(err);&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    collection.findone(&amp;#123;uid:uid&amp;#125;,&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;err&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(err) &amp;#123;callback(err);&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(doc)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                            callback(&lt;span class=&quot;string&quot;&gt;&#39;occupied&#39;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                        &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                            &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; user = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                                uid: uid,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                                user: user_info&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                            &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                            collection.insert(user, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;err&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                                callback(err);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                            &amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                    &amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                &amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果你对Node.js或MongoDB不熟悉，没关系，不需要去理解细节，只要看清楚大概的逻辑即可。这段代码中用到了闭包的层层嵌套，每一层嵌套都是一个回调函数。回调函数不会立即执行，而是等待相应请求处理完成后由请求的函数回调。我们可以看到，在嵌套的每一层中都有对callback的引用，而且最里层还用到了外层定义的uid变量。由于闭包机制的存在，即使外层函数已经执行完毕，其作用域内申请的变量也不会释放，因为里层的函数还有可能引用到这些变量，这样就完美地实现了嵌套的异步回调。&lt;/p&gt;
&lt;h3 id=&quot;2-实现私有成员&quot;&gt;&lt;a href=&quot;#2-实现私有成员&quot; class=&quot;headerlink&quot; title=&quot;2.实现私有成员&quot;&gt;&lt;/a&gt;2.实现私有成员&lt;/h3&gt;&lt;p&gt;我们知道，Javas的对象没有私有属性，也就是说对象的每一个属性都是暴露给外部的。这样可能会有安全隐患，譬如对象的使用者直接修改了某个属性，导致对象内部数据的一致性受到破坏等。Javascript通过约定在所有私有属性前加上下划线（例如_myPrivateProp）,表示这个属性是私有的，外部对象不应该直接读写它。但这只是个非正式的约定，假设对象的使用者不这么做，有没有更严格的机制呢？答案是有的，通过闭包可以实现。让我们再看看前面那个例子：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; generateClosure = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; count = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; get = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        count++;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; count;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; get;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; counter = generateClosure();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(counter());&lt;span class=&quot;comment&quot;&gt;//输出1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(counter());&lt;span class=&quot;comment&quot;&gt;//输出2&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(counter());&lt;span class=&quot;comment&quot;&gt;//输出3&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们可以看到，只有调用counter()才能访问到闭包内的count变量，并按照规则对其增加1，除此之外决无可能用其他方式找到count变量。受到这个简单例子的启发，我们可以把一个对象用闭包封装起来，只返回一个”访问器”对象，即可实现对细节隐藏。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/0060lm7Tgw1f3zslcb9f5j309o05d74c.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;闭包（closure）是函数式编程中的概念，出现于20世纪60年代。闭包的严格定义是“由函数（环境）及其封闭式的自由变量组成的集合体。”这个定义对于大家来说有些晦涩难懂，所以让我们先通过例子和不那么严格的解释来说明何为闭包，然后再举例说明一些闭包的经典用途。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://nickgo.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Javascript" scheme="http://nickgo.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>如何直接在github上预览html效果</title>
    <link href="http://nickgo.com/2016/04/17/%E5%A6%82%E4%BD%95%E7%9B%B4%E6%8E%A5%E5%9C%A8github%E4%B8%8A%E9%A2%84%E8%A7%88html%E6%95%88%E6%9E%9C/"/>
    <id>http://nickgo.com/2016/04/17/如何直接在github上预览html效果/</id>
    <published>2016-04-17T06:16:35.000Z</published>
    <updated>2016-04-17T07:02:32.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/0060lm7Tgw1f2zoo4eo2ej30l10d9gnb.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我们经常会在&lt;strong&gt;Github&lt;/strong&gt;上托管我们的web项目，但一般只能在上面看到我们的源码，如果想要在线预览我们的项目该怎么办呢？其实只需要很简单的方法就能做到了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;Github项目效果在线预览&quot;&gt;&lt;a href=&quot;#Github项目效果在线预览&quot; class=&quot;headerlink&quot; title=&quot;Github项目效果在线预览&quot;&gt;&lt;/a&gt;Github项目效果在线预览&lt;/h2&gt;&lt;p&gt;在&lt;strong&gt;Github&lt;/strong&gt;上托管的项目中经常会存放一些demo的html文件在里面，比如像是下面这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/0060lm7Tgw1f2zoo4eo2ej30l10d9gnb.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果直接点击html文件只能看到html文件的源码，那么有没有什么办法可以直接在浏览器看到html的网页效果而不用克隆到本地呢？&lt;/p&gt;
&lt;p&gt;做法是&lt;strong&gt;&lt;a href=&quot;http://htmlpreview.github.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://htmlpreview.github.com/&lt;/a&gt;&lt;/strong&gt;直接把github上的html文件链接复制在上面即可，或者直接在你的html文件链接前加上&lt;strong&gt;&lt;a href=&quot;http://htmlpreview.github.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://htmlpreview.github.io/?&lt;/a&gt;&lt;/strong&gt;如图：&lt;br&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/0060lm7Tgw1f2zoo4dm1bj30lj08raaw.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;比如，Github上我有这么一个文件&lt;strong&gt;&lt;a href=&quot;https://github.com/Nicksapp/To-Do-List/blob/master/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/Nicksapp/To-Do-List/blob/master/index.html&lt;/a&gt;&lt;/strong&gt;,直接访问看到的是这样的：&lt;br&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/0060lm7Tgw1f2zoo4nsmcj30pa0etjvo.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;只有这样访问我们的文件才能直接在网页中预览到效果：&lt;strong&gt;&lt;a href=&quot;http://htmlpreview.github.io/?https://github.com/Nicksapp/To-Do-List/blob/master/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://htmlpreview.github.io/?https://github.com/Nicksapp/To-Do-List/blob/master/index.html&lt;/a&gt;&lt;/strong&gt;像是这样：&lt;br&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/0060lm7Tgw1f2zp683ug6j30s00jqjtr.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;赶紧拿自己的项目试试吧！&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/0060lm7Tgw1f2zoo4eo2ej30l10d9gnb.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我们经常会在&lt;strong&gt;Github&lt;/strong&gt;上托管我们的web项目，但一般只能在上面看到我们的源码，如果想要在线预览我们的项目该怎么办呢？其实只需要很简单的方法就能做到了&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="实用技巧" scheme="http://nickgo.com/categories/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="github" scheme="http://nickgo.com/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>Git常用命令总结</title>
    <link href="http://nickgo.com/2016/04/04/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
    <id>http://nickgo.com/2016/04/04/Git常用命令总结/</id>
    <published>2016-04-03T16:30:28.000Z</published>
    <updated>2016-04-03T16:48:56.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/0060lm7Tgw1f2jzaz7beqj30cn05ajrq.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;学会这些命令，你就可以熟练的使用Git工具，听上去就让人兴奋，嘿嘿！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;基本命令&quot;&gt;&lt;a href=&quot;#基本命令&quot; class=&quot;headerlink&quot; title=&quot;基本命令&quot;&gt;&lt;/a&gt;基本命令&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git config --global user.name &amp;quot;Your Name&amp;quot;&lt;/code&gt;设置你的仓库用户名（用于标识提交者）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git config --global user.name &amp;quot;email@example.com&amp;quot;&lt;/code&gt;设置你的仓库邮箱（用于标识提交者）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git init&lt;/code&gt;初始化一个git仓库&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git add --all&lt;/code&gt;添加所有更改文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git add filename&lt;/code&gt;指定添加名为filename文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git commit -m &amp;quot;commit message&amp;quot;&lt;/code&gt;添加更改的信息，必须要有，不然报错，不建议不加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git status&lt;/code&gt;查看git当前状态&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git diff filename&lt;/code&gt;查看filename修改内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git log&lt;/code&gt;查看最近的提交日志&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git log --pretty=oneline&lt;/code&gt;单行显示提交日志&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git reset --hard commitID&lt;/code&gt;利用&lt;code&gt;git log&lt;/code&gt;得到的commitID返回版本&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git reset --hard HEAD^&lt;/code&gt;回到上一个版本&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git reflog&lt;/code&gt;查看命令的历史，可以找到&lt;code&gt;git log&lt;/code&gt;看不到的commitID，因为&lt;code&gt;git log&lt;/code&gt;只显示当前的提交日志，如果你提交了一次，退回版本后又后悔了，就能查看上次提交的commitID&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git checkout -- filename&lt;/code&gt;利用版本库中的版本替换工作区中的文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git reset HEAD filename&lt;/code&gt;撤销add，回到工作区&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git rm filename&lt;/code&gt;删除文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git remote add origin https://github.com/pengloo53/learngit.git&lt;/code&gt;将本地库关联到github远程库上&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git push -u origin master&lt;/code&gt;第一次推送的时候要加上&lt;code&gt;-u&lt;/code&gt;参数，可以将本地库的master分支与远程库的master分支关联起来；下次提交就不需要加&lt;code&gt;-u&lt;/code&gt;了。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git clone https://github.com/pengloo53/learngit.git&lt;/code&gt;克隆远程库到本地&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;分支管理&quot;&gt;&lt;a href=&quot;#分支管理&quot; class=&quot;headerlink&quot; title=&quot;分支管理&quot;&gt;&lt;/a&gt;分支管理&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git checkout -b dev&lt;/code&gt;创建dev分支并切换到dev&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git branch&lt;/code&gt;查看当前分支&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git merge dev&lt;/code&gt;合并指定分支到当前分支，如，你现在master分支，那么执行命令就将dev分支合并到了master分支上&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git branch -d dev&lt;/code&gt;删除dev分支&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git log --graph --pretty=oneline --abbrev-commit&lt;/code&gt;查看分支合并图&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git merge --no-ff -m &amp;quot;merge with no-ff&amp;quot; dev&lt;/code&gt;禁用「Fast forward」，也就是保留分支的相关信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git stash&lt;/code&gt;将工作区现场储藏起来，等以后恢复后继续工作。通常用于处理更为着急的任务时&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git stash list&lt;/code&gt;查看保存的工作现场&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git stash apply&lt;/code&gt;恢复工作现场&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git stash drop&lt;/code&gt;删除stash内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git stash pop&lt;/code&gt;恢复的同时直接删除stash内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git stash apply stash@{0}&lt;/code&gt;恢复指定的工作现场，当你保存了不只一份工作现场时&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git branch -D feature-vulcan&lt;/code&gt;强行删除分支。用于不需要合并，就地删除的情况&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git remote&lt;/code&gt;查看远程库的信息，一般返回origin&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git remote -v&lt;/code&gt;查看远程库的详细信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git push origin master&lt;/code&gt;将本地master分支推送到远程master分支(&lt;br&gt;  master分支为主分支，因此要时刻与远程同步；&lt;br&gt;  dev分支为开发分支，团队成员都需要在上面工作，所以也需要与远程同步；&lt;br&gt;  bug分支只用于在本地修复bug，没有必要推送到远程；&lt;br&gt;  feature新功能分支是否推送到远程，取决于你是否和其他人合作在上面开发。&lt;br&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git clone https://github.com/pengloo53/learngit.git&lt;/code&gt;将远程库克隆到本地，默认只能看到master分支&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git checkout -b dev origin/dev&lt;/code&gt;创建远程dev分支到本地&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git pull&lt;/code&gt;将远程分支的最新内容抓取下来&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git branch --set-upstream dev origin/dev&lt;/code&gt;将本地dev分支与远程dev分支之间建立链接&lt;br&gt;&lt;br&gt;&lt;em&gt;多人协作工作模式&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;首先，可以试图用&lt;code&gt;git push origin branch-name&lt;/code&gt;推送自己的修改；&lt;/li&gt;
&lt;li&gt;如果推送失败，则因为远程分支比你的本地更新，需要先用&lt;code&gt;git pull&lt;/code&gt;试图合并（如果&lt;code&gt;git pull&lt;/code&gt;提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令&lt;code&gt;git branch --set-upstream branch-name origin/branch-name&lt;/code&gt;）; &lt;/li&gt;
&lt;li&gt;如果合并有冲突，则解决冲突，并在本地提交； &lt;/li&gt;
&lt;li&gt;没有冲突或者解决掉冲突后，再用&lt;code&gt;git push origin branch-name&lt;/code&gt;推送就能成功！&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;标签管理&quot;&gt;&lt;a href=&quot;#标签管理&quot; class=&quot;headerlink&quot; title=&quot;标签管理&quot;&gt;&lt;/a&gt;标签管理&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git tag v1.0&lt;/code&gt;给当前分支打上标签&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git tag&lt;/code&gt;查看所有的标签，按时间顺序列出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git log --pretty=oneline --abbrev-commit&lt;/code&gt;缩略commitID并单行显示提交信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git tag v0.9 commitID&lt;/code&gt;通过上一条命令查看commitID，然后打上标签。用于忘记打标签的情况，因为标签其实就是只想某个commitID的指针，默认情况下，标签打在最新的提交上&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git show v0.9&lt;/code&gt; 查看标签信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git tag -a v0.1 -m &amp;quot;version 0.1 released&amp;quot; commitID&lt;/code&gt;创建带有说明的标签，&lt;code&gt;-a&lt;/code&gt;指定标签名，&lt;code&gt;-m&lt;/code&gt;指定说明文字&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git tag -d v0.1&lt;/code&gt; 删除标签v0.1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git push origin v1.0&lt;/code&gt;推送标签1.0到远程&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git push origin --tags&lt;/code&gt;推送所有的标签到远程&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git push origin :refs/tags/v0.9&lt;/code&gt;删除远程标签，但是前提是要先在本地删除对应标签&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;自定义Git&quot;&gt;&lt;a href=&quot;#自定义Git&quot; class=&quot;headerlink&quot; title=&quot;自定义Git&quot;&gt;&lt;/a&gt;自定义Git&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git config --global color.ui true&lt;/code&gt;让Git显示颜色&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.gitignore&lt;/code&gt;在这个文件里编辑你要忽略的文件，并提交到Git中，就可以忽略特殊文件的检查。如将&lt;code&gt;-.db&lt;/code&gt;写入&lt;code&gt;.gitignore&lt;/code&gt;文件中，将忽略所有db文件。可以参考github收集的所有.gitignore&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git config --global alias.st status&lt;/code&gt;将status的别名设置成st，那么&lt;code&gt;git st&lt;/code&gt;=&lt;code&gt;git status&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git config --global alias.unstage &amp;#39;reset HEAD&amp;#39;&lt;/code&gt;那么&lt;code&gt;git reset HEAD filename&lt;/code&gt;=&lt;code&gt;git unstage filename&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git config --global alias.last &amp;#39;log -1&amp;#39;&lt;/code&gt;敲&lt;code&gt;git last&lt;/code&gt;就显示最后一次提交了&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;搭建Git服务器&quot;&gt;&lt;a href=&quot;#搭建Git服务器&quot; class=&quot;headerlink&quot; title=&quot;搭建Git服务器&quot;&gt;&lt;/a&gt;搭建Git服务器&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;sudo apt-get install git&lt;/code&gt;安装Git&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sudo adduser git&lt;/code&gt;添加Git用户&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sudo git init --bare sample.git&lt;/code&gt;初始化git仓库&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sudo chown -R git:git sample.git&lt;/code&gt;修改仓库的所属用户为git&lt;br&gt;&lt;/li&gt;
&lt;li&gt;将git用户的信息&lt;code&gt;git:x:1001:1001:,,,:/home/git:/bin/bash&lt;/code&gt;改成&lt;code&gt;git:x:1001:1001:,,,:/home/git:/bin/git-shell&lt;/code&gt;,为了禁用shell登录&lt;br&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git clone git@server:/director/sample.git&lt;/code&gt;克隆Git服务器上的仓库&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/0060lm7Tgw1f2jzaz7beqj30cn05ajrq.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;学会这些命令，你就可以熟练的使用Git工具，听上去就让人兴奋，嘿嘿！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://nickgo.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="git" scheme="http://nickgo.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>My New Post</title>
    <link href="http://nickgo.com/2016/03/31/my-new-post/"/>
    <id>http://nickgo.com/2016/03/31/my-new-post/</id>
    <published>2016-03-31T14:59:10.000Z</published>
    <updated>2016-04-03T09:50:20.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/0060lm7Tgw1f2jno83esjj311y0lcq5o.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;认识hexo&quot;&gt;&lt;a href=&quot;#认识hexo&quot; class=&quot;headerlink&quot; title=&quot;认识hexo&quot;&gt;&lt;/a&gt;认识hexo&lt;/h2&gt;&lt;p&gt;hexo是一款基于Node.js的静态博客框架，可以生成静态文件并且一键部署到github pages上，并且他可以使用markdown来编写文章，十分简单。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/0060lm7Tgw1f2jno83esjj311y0lcq5o.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="test" scheme="http://nickgo.com/categories/test/"/>
    
    
      <category term="博客，测试" scheme="http://nickgo.com/tags/%E5%8D%9A%E5%AE%A2%EF%BC%8C%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
</feed>
